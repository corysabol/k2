#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const inquirer = require('inquirer');
const chalk = require('chalk');
const figlet = require('figlet');
const kdbxweb = require('kdbxweb');
const { program } = require('commander');
const argon2 = require('kdbxweb/test/test-support/argon2');

// hacky use of the test implementation of argon2 found in kdbxweb
kdbxweb.CryptoEngine.argon2 = argon2;
/*kdbxweb.CryptoEngine.argon2 = (password, salt,
    memory, iterations, length, parallelism, type, version
) => {
    // your implementation makes hash (Uint32Array, 'length' bytes)
    return Promise.resolve(hash);
};*/

function getRandomPass() {}

function askPassword(prompt) {
  const questions = [
    {
      name: 'password',
      type: 'password',
      message: prompt,
      validate: function(value) {
        if (value.length) {
          return true;
        } else {
          return 'Please enter your password.';
        }
      }
    },
  ];
  return inquirer.prompt(questions);
}

program.version('0.1.0');
program
  .command('list <dbpath>')
  .alias('l')
  .description('list the entries in the specified database file')
  .option('-g --group <group>', 'The group to search in')
  .option('-t --title <title>', 'The title of the entry to list')
  .option('-a --all', 'List all entries', false)
  .action(async (dbpath, options) => {
    let password = await askPassword();
    let credentials = new kdbxweb.Credentials(kdbxweb.ProtectedValue.fromString(password.password));
    const data = new Uint8Array(fs.readFileSync(dbpath));
    kdbxweb.Kdbx.load(data.buffer, credentials)
      .then(db => {
        db.groups[0].forEach((entry, group) => {
          if ((options.all && group) || (group && group.name === options.group)) {
            console.log(
              chalk.blue(group.name)
            );
          }
          if ((options.all && entry) || (entry && entry.parentGroup.name === options.group)) {
            console.log(
              chalk.blue(
                `  Title:    ${entry.fields.Title}\n` +
                `  UserName: ${entry.fields.UserName}\n` +
                `  Password: ${entry.fields.Password}\n` +
                `  URL:      ${entry.fields.URL}\n` +
                `  Notes:    ${entry.fields.Notes}\n`
              )
            );
          }
        });
      })
      .catch(err => console.log(err));
  });

program
  .command('add <dbpath>')
  .alias('a')
  .description('add a new entry to the database with an autogenerated password')
  .option('-g --group <groupname>', 'The group to add the entry to', 'default')
  .option('-t --title <title>', 'The title of the entry')
  .option('-u --user <username>', 'The username of the entry')
  .option('--url <url>', 'The URL of the entry')
  .option('-n --note <note>', 'A note for the entry')
  .option('-a --askpass', 'If supplied the user will be prompted for a password, otherwise a random one is generated', false)
  .action(async (dbpath, options) => {
    let password = await askPassword('Enter the database password:');
    let credentals = new kdbxweb.Credentials(kdbxweb.ProtectedValue.fromString(password.password));
    // load the db
    console.log(
      chalk.yellow('Opening db...')
    );
    const data = new Uint8Array(fs.readFileSync(dbpath));
    let dbPromise = kdbxweb.Kdbx.load(data.buffer, credentals);
    dbPromise
      .then(async db => {
        let password;
        console.log(
          chalk.green('Successfully opened db!')
        );
        if (options.askpass) {
          let _password = await askPassword('Enter a password for the entry:');
          password = _password.password;
        } else {
          password = getRandomPass();
        }
        password = kdbxweb.ProtectedValue.fromString(password);
        let group;
        if (options.group && options.group !== 'default') {
          group = db.createGroup(db.getDefaultGroup(), options.group);
        } else {
          group = db.getDefaultGroup();
        }
        let entry = db.createEntry(group);
        entry.fields.Title = options.title;
        entry.fields.UserName = options.user;
        entry.fields.URL = options.url;
        entry.fields.Password = password;
        entry.fields.Notes = options.note;
        console.log(entry.fields);
        console.log(
          chalk.yellow('saving DB...')
        );
        db.save()
          .then(db => {
            fs.writeFileSync(dbpath, Buffer.from(db));
            console.log(chalk.green('DB saved!'))
          })
      })
      .catch(err => {
        console.log(
          chalk.red(err)
        );
      });
  });

program
  .command('newdb <dbpath>')
  .alias('n')
  .option("-n --dbname <dbname>", "the name of the database")
  .description('create a new database file')
  .action(async (dbpath, options) => {
    console.log(
      chalk.yellow('initializing DB')
    );

    let password = await askPassword();
    let credentials = new kdbxweb.Credentials(kdbxweb.ProtectedValue.fromString(password.password));
    let newDb = kdbxweb.Kdbx.create(credentials, options.dbname);
    //let group = newDb.createGroup(newDb.getDefaultGroup(), 'k2');
    //let entry = newDb.createEntry(group);
    // write the database file out.
    newDb.upgrade();
    newDb.save()
      .then(db => {
        fs.writeFileSync(dbpath, Buffer.from(db));
        console.log(
          chalk.green(`${dbpath} created successfully!`)
        );
      })
      .catch(err => {
        console.log(
          chalk.red(err)
        );
      });
    console.log('');
  });

program.option('-s --silent', 'silence output');

async function main() {
  if (!program.silent) {
    console.log(
      chalk.green(
        figlet.textSync('k2', { horizontalLayout: 'full' })
      )
    );
  }
  program.parseAsync(process.argv);
}
main();
